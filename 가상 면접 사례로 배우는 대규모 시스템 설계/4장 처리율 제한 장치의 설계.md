# 4장 처리율 제한 장치의 설계
네트워크 시스템에서 처리율 제한 장치(rate limiter)는 클라이언트/서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치

#### API에 처리율 제한 장치를 두면 좋은 점?
- DoS 공격에 의한 자원 고갈 방지
- 비용 절감
- 서버 과부하 막을 수 있음

## 상세 설계

<img width="748" height="642" alt="Image" src="https://github.com/user-attachments/assets/8962bf7b-bc9c-47fa-82fd-5c144561e993" />


- 클라이언트의 요청은 처리율 제한 미들웨어에 가장 먼저 도달
- 제한 규칙 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져옴
  - 제한 초과 시 429 에러
  - 제한 초과되지 않았을 시 API 서버로 보냄

## 분산 환경에서의 구현
### 경쟁 조건(race condition)

<img width="562" height="295" alt="스크린샷 2025-10-02 오전 11 50 34" src="https://github.com/user-attachments/assets/11056a15-abf8-40d8-8f5a-91ef4fe4d09b" />

- 위와 같은 상황에서는 기대 결과가 5이지만 실제로는 4가 됨
- 가장 널리 알려진 해결책은 락(lock) 이지만 락은 시스템의 성능을 상당히 떨어뜨림

#### 해결책 1) Lua 스크립트
- Redis에서 Lua 스크립트는 원자적으로 실행
- 구현 예시
    ```python
    lua_script = """
    local current = tonumber(redis.call('GET', KEYS[1]) or 0)
    redis.call('SET', KEYS[1], current + 1)
    return current + 1
    """

    # 스크립트 실행
    result = redis.eval(lua_script, 1, 'counter')
     ```
- 작동 방식
    ```yaml
    스레드 A: Lua 스크립트 실행 시작
    → counter 읽기(3) + 증가 + 저장(4) → 완료
    
    스레드 B: 대기 중... (스레드 A의 스크립트가 끝날 때까지)
    → counter 읽기(4) + 증가 + 저장(5) → 완료

    최종 결과: counter = 5 
    ```
- 장점
  - 네트워크 왕복 횟수 감소 (한번의 요청으로 여러 작업 수행)
  - 원자성 보장
  - 락보다 성능 좋음

#### 해결책 2) Sorted Set
- Sorted Set의 `ZINCRBY` 명령은 Redis 서버 내부에서 원자적으로 값을 증가시킴
- 구현 예시
    ```python
    # Sorted Set 사용
    redis.zadd('counters', {'counter': 3})  # 초기값 설정

    # 스레드 A와 B가 동시에 실행해도 안전
    redis.zincrby('counters', 1, 'counter')  # 원자적으로 +1
    ```
- 작동 방식
    ```yaml
    초기: counters = {'counter': 3}

    스레드 A: ZINCRBY counters 1 counter → 4 반환
    스레드 B: ZINCRBY counters 1 counter → 5 반환

    최종: counters = {'counter': 5} 
    ```

## 동기화 이슈
- 처리율 제한 장치를 여러 개 두게 되면 동기화가 필요해짐
- 웹 계층은 state-less 하기 때문에 클라이언트는 아래처럼 각기 다른 제한 장치로 보내는게 가능
   <img width="641" height="211" alt="스크린샷 2025-10-02 오후 12 14 57" src="https://github.com/user-attachments/assets/3e9c7e61-b4ef-4c7e-b3b7-7d4a888de111" />

### 해결책 1) Sticky Session
- 같은 클라이언트로부터의 요청이 항상 같은 처리율 제한 장치로 가도록 하는 것
- 규모 면에서 확장 가능하지 않기 때문에 추천하지 않음

### 해결책 2) 중앙 집중형 데이터 저장소 사용 (ex. Redis)

<img width="641" height="211" alt="스크린샷 2025-10-02 오후 12 16 45" src="https://github.com/user-attachments/assets/6580e81e-9669-44c9-930b-c92d832f5122" />
