# 5장 수명주기 관리

#### 💡 컨테이너화된 애플리케이션이 좋은 자격을 갖추려면 관리 플랫폼에 의해 생성된 이벤트를 받아 그에 맞춰 수명주기를 조절해야 함

## 문제
- 정상상태 확인 API는 플랫폼이 애플리케이션에 대한 통찰력(정보 추출)을 얻기 위해 지속적으로 점검하는 읽기 전용 종단점
- 상태 모니터링 외에도 플랫폼은 애플리케이션에 명령어를 보내고 애플리케이션이 그 명령어에 반응할 것을 기대
- 플랫폼은 자신이 관리하는 애플리케이션에 대해 언제든지 시작/중지를 결정 가능 → 어떤 이벤트가 중요한지 결정하는 것은 애플리케이션의 몫
- 애플리케이션은 수명주기 관리로부터 혜택을 얻거나, 이런 서비스가 필요하지 않은 경우 수명주기 관리를 무시하기도 함

## 해결책
- 프로세스 상태 확인만으로는 애플리케이션의 정상상태를 나타내는데 충분하지 않음 → 모니터링을 위한 별도 API 필요
- 위와 마찬가지로, 프로세스 실행/중지하는데 프로세스 모델만 사용하는 것은 충분하지 않음
   → 실행을 준비하는데 도움이 필요하거나, 깔끔한 종료 절차가 필요한 애플리케이션 존재

<img width="344" alt="스크린샷 2025-02-16 오후 6 01 52" src="https://github.com/user-attachments/assets/210593c7-41ac-43c5-97f9-74880ec1633b" />

- 일부 이벤트는 플랫폼에 의해 발생되고, 원하는 경우 컨테이너가 이벤트를 수신 및 처리 가능
- 애플리케이션의 배포 단위는 파드이며, 파드는 하나 이상의 컨테이너로 구성
  - 파드 레벨에서 컨테이너 수명주기 관리에 도움을 주는 초기화 컨테이너(14장 참고), 지연 컨테이너(defer-container) 있음
  - 개별 컨테이너 레벨에 적용되는 것으로는 **이벤트, 훅** 있음

### 시그텀 신호(SIGTERM)
- 쿠버네티스가 컨테이너를 멈추기로 결정할 때마다 컨테이너는 SIGTERM 신호를 수신
- 시그텀이란, 쿠버네티스가 갑작스러운 SIGKILL 신호를 보내기 전에 컨테이너가 깨끗하게 종료될 수 있도록 슬쩍 찔러보는 것
- 시그텀 신호를 받은 어플리케이션은 가능한 한 빨리 멈춰야 함 (컨테이너를 깨끗하게 종료하기 위한 좋은 순간은 시그텀 신호에 반응하는 것)

### 시그킬 신호 (SIGKILL)
- 시그텀 신호 수신 후에도 컨테이너 프로세스가 종료되지 않는다면 시그킬 신호에 의해 강제 종료됨
- 쿠버네티스는 시그킬 신호를 즉시 보내지는 X, 시그텀 신호 발생 후 기본적으로 **유예시간 30초 기다림**
- 유예시간은 `.spec.terminationGracePeriodSeconds` 필드를 사용해 개별 파드마다 정의 가능 (이후 재정의 가능)

### 시작 후 훅
- 수명주기 관리를 위해 프로세스 신호만을 사용하는 것은 다소 제한적
- `postStart`, `preStop` 같은 추가적인 수명주기 훅을 사용 가능

#### `postStart` 훅 예제
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    env:
    # Indication for the application that it should wait for the postStart file to be
    # created.
    - name: WAIT_FOR_POST_START
      value: "true"
    lifecycle:
      postStart:
        exec:
          command: # 30 초 기다렸다 컨테이너 시작.
          - sh
          - -c
          - sleep 30 && echo "Wake up!" > /tmp/postStart-done
```
- `postStart` 명령은 컨테이너가 생성된 후 주 컨테이너 프로세스와 비동기적으로 실행됨
- 많은 애플리케이션 초기화와 준비 로직이 컨테이너 시작 단계의 한 부분으로 구현될 수 있지만, `postStart`는 여전히 일부 사용 활용
- `postStart` 동작은 블록킹 호출이며, `postStart` 핸들러가 완료될때까지 컨테이너는 Waiting 상태로 남아있고, 파드는 Pending을 유지
- `postStart`의 특성은 주 컨테이너 프로세스의 초기화 시간을 벌기 위해 컨테이너의 시작 상태 지연
- 4장의 정상상태 점검 패던과 유사하게 아래와 같은 핸들러 타입 지원
  - `exec`: 컨테이너 안에서 직접적으로 명령어 실행
  - `httpGet`: 하나의 파드 컨테이너에 의해 공개된 포트로 HTTP GET 요청 수행

#### ⚠️ 주의점
- `postStart`의 실행은 보장되지 않으므로, 중요한 로직 수행할 때는 매우 주의해야 함
 - 훅은 컨테이너 프로세스와 병렬로 실행되기 때문에 컨테이너가 시작되기 전에 훅이 실행될 수도 있음
 - 훅은 최소 한번 실행의 의미로 설계되었으므로, 구현 시 중복 실행될수 있음을 염두해야 함
 - HTTP 요청 실해 시 재시도를 수행하지 않음

### 종료 전 훅
- `preStop` 훅은 컨테이너가 종료되기 전에 컨테이너로 전송되는 블록킹 호출
- 시그텀 신호와 동일한 의미 지니며, **컨테이너가 시그텀에 응답 불가능할 때 컨테이너를 정상적으로 종료하기 위해 사용**해야 함

#### `preStop` 훅 예제
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: random-generator
spec:
  containers:
  - image: k8spatterns/random-generator:1.0
    name: random-generator
    env:
    # Indication for the application that it should wait for the postStart file to be
    # created.
    - name: WAIT_FOR_POST_START
      value: "true"
    lifecycle:
      # Call out to the /shutdown endpoint. Check logs for the result
      preStop:
        httpGet:
          port: 8080
          path: shutdown
```
- 시그텀 알림에 의해 컨테이너 런타임이 컨테이너 삭제를 호출하여 시그킬 알림을 트리거하기 전에 완료되어야 함
- `preStop`이 블록킹되거나, 계속 진행 중이거나, 실패한 결과가 리턴되더라도, 컨테이너가 삭제되거나 프로세스가 종료되는 상황을 막을 순 없음
- **`preStop`은 정상적인 애플리케이션 종료를 위한 시그텀 신호의 편리한 대안**일 뿐
- 앞서 설명되었던 `postStart` 훅과 동일한 핸들러 유형 및 동작 제공

### 그 밖의 수명주기 제어
- 위에서 설명했던 부분들은 컨테이너 수명주기 이벤트가 발생했을 때 명령어를 실행할 수 있는 훅
- 컨테이너 레벨이 아닌 파드 레벨에서 또 다른 메커니즘으로 초기화 명령 수행 가능

#### 파드 레벨 초기화 (14장)
- 일반 애플리케이션 컨테이너와는 달리 초기화 컨테이너는 순차적으로 실행되고, 완료될 때까지 실행되며, 파드 내 애플리케이션 컨테이너가 시작되기 전에 실행
- 수명주기 훅과 초기화 컨테이너는 각각 컨테이너 레벨과 파드 레벨에서 서로 다른 세분성으로 작동하기 때문에 서로 바꿔서 사용하거나 보완하여 사용 가능
- 특정한 타이밍 보장을 요구하는 경우를 제외하고는 어떤 메커니즘을 사용할 지에 대한 엄격한 규칙은 없음
   (수명주기 훅, 초기화 컨테이너 모두 생략하고 bash 스크립트를 사용할 수도 있음. 다만 관리가 힘들 뿐)

## 정리
- 클라우드 네이티브 플랫폼이 제공하는 주요 이점 중 하나는 잠재적으로 신뢰할 수 없는 클라우드 인프라스트럭처 위 애플리케이션을 **신뢰성 있게 예측 가능한 범위내에서 실행하고 확장**할 수 있다는 것
  → 플랫폼 위에서 실행되는 애플리케이션에 대해 제약과 보장된 기능 제공
- 이러한 이벤트를 잘 처리/대응함을 통해 사용 중인 서비스에 미치는 영향 최소화하면서 애플리케이션을 정상적으로 시작/종료 가능
- 향후에는 애플리케이션이 스케일업되어야 할 때 힌트를 주는 이벤트나, 애플리케이션이 멈추는 것을 막기 위한 자원 해제 이벤트가 훨씬 많아질 것
