# Ch6 자동 배치
자동 배치 패턴: 쿠버네티스 스케줄러의 핵심 기능
컨테이너 자원 요청을 만족하고 스케줄링 정책을 준수하는 노드에 신규 파드를 할당해주는 기능

## 문제
- 컨테이너와 파드를 **어떻게 적절한 노드에 배치할 수 있는지**의 문제
  - 개별적으로 노드에 할당 배치하는 방식으로는 관리 불가
- 컨테이너 관련 고려사항: 컨테이너간 의존성, 컨테이너와 노드 간의 의존성, 자원 요구사항, 시간에 따른 변경사항
- 사용 가능한 자원 관련 고려사항: 시간, 클러스터의 확장 및 축소, 이미 배치된 컨테이너의 자원 소비량
- 컨테이너의 배치는 가용성, 성능 그리고 분산 시스템의 용량에도 영향을 준다

## 해결책
- 쿠버네티스 스케줄러
  - 새로 생성된 파드 정의 조회하고 파드를 노드에 할당하는 역할을 한다
  - 다양한 상황에서 모든 파드에 대해 적절한 노드를 찾는다
  - 고려사항: 런타임 의존성, 자원 요구사항, 및 고가용성 가이드 정책 
  - 수행: 파드의 수평적 확장, 상호 호출 시 성능 및 낮은 지연 시간을 위한 파드들의 가까운 배치
  - 필요조건: 가용한 용량을 확보한 노드, 선언된 자원 프로파일 및 가이드 정책을 갖춘 컨테이너

### 가용한 노드 자원
- 새로운 파드를 실행하기 위해 충분한 자원 용량을 확보한 노드
  - 스케줄러는 파드가 요청한 자원의 총합이 할당 가능한 노드의 용량보다 적다는 것을 확인해야한다
  - 애플리케이션 파드에 대한 용량 = 하나의 노드에 가용한 용량 = 큐블릿, 컨테이너 런타임 같은 쿠버네티스 데몬 - sshd, udev같은 os 시스템 데몬
    - 자원 부족 문제 발생 가능성에 대한 임시 해결 방법: 아무 일도 하지 않는 플레이스홀더 파드를 실행
      - 추적되지 않는 컨테이너의 자원 소비를 나타내거나 예약하기 위해서만 생성

### 컨테이너 자원 요구
- 컨테이너가 런타임 의존성과 자원 요구 정의를 가져야한다 (ch2 참조)
- 컨테이너에 request와 limit을 갖는 자원 프로파일과 스토리지 또는 포트 같은 환경 의존성을 선언한다

### 배치(placement) 정책
- 우선순위 정책
  - 스케줄러 정책과 커스텀 스케줄러는 관리자만이 클러스터 설정으로 정의할 수 있다. 일반 사용자는 미리 정의된 스케줄러만 참조 가능
  - ```predicates``` : 자격 없는 노드를 필터링하여 제외하는 규칙
  - ```priorities```:  설정에 따라 사용 가능한 노드를 정렬하는 규칙

### 스케줄링 프로세스
- 파드는 배치 정책에 따라 특정 용량을 가진 노드에 할당된다
  - 노드에 할당되지 않은 파드가 생성 -> [스케줄러] 필터링 정책 적용 -> [스케줄러] 가중치에 의해 남은 노드 정렬 -> [스케줄러] 파드를 노드에 할당
  - 파드부터 노드까지의 할당 작업은 스케줄러에 맡기는 것이 좋으며, 배치 로직을 세세하게 관리하지 않는 것이 낫다
  - 단 특정 노드에 강제 할당이 필요한 경우 node selector를 사용해 수행 가능
    - `.spec.nodeSelector` : 파드의 필드
  - 커스텀 레이블 외에도 일부 기본 레이블을 이용하는 것도 가능 (os, hostname 등)

### node affinity 노드 어피니티
- node selector 접근 방식을 일반화한 것, required / preferred 규칙을 지정할 수 있다
  - ```required``` : 필수 규칙은 파드가 노드에 스케줄링 위해서 반드시 충족되어야 함
  - ```preferred``` : 선호 규칙은 반드시 충족되어야 하는 것은 아며 일치하는 노드의 가중치를 증가시켜 선택되게 함
  - In, notIn, Exists, DoesNotExist, Gt, Lt 같은 연산자를 활용해 표현 가능한 제약조건의 종류를 크게 확장
- 노드 어피니티는 nodeSelector 로 충분하지 않을 때 선택

### 파드 어피니티(pod affinity)와 파드 안티어피니티(pod antiaffinity)
- 파드 간의 의존성(파드가 또 다른 파드의 상대적 위치를 지정) 반영이 필요한 경우
- 고가용성을 위해 파드를 분산시키는 방법을 표현하거나, 지연 시간 개선을 위해 파드를 함께 포장하고 배치하는 방법을 표현해야하는 경우
- 노드 어피니티는 노드 세분성으로 작동하지만, 파드 어피니티는 노드로 제한되지 않고 다중 토폴로지 레벨에서 규칙을 표현할 수 있다

### 테인트(taint)와 톨러레이션(toleration)
- 노드 어피니티는 파드가 노드를 선택할 수 있는 속성인 반면, 테인트와 톨러레이션은 파드의 스케줄 여부를 노드가 제어할 수 있도록 하는 속성
  - 파드가 테인트에 대한 톨러레이션이 없다면 해당 노드에 스케줄링 될 수 없다
  - 노드에 스케줄링을 허용하는 옵트인 opt-in 규칙 <-> 어피니티 규칙은 실행할 노드를 명시적으로 선택하여 선택되지 않은 노드를 모두 제외하는 옵트아웃 opt-out
    - 노드에 스케줄링을 금지하는 hard taint(effect=NoSchedule)
    - 가능한 한 노드에 스케줄링을 피하게 해주는 soft taint(effect=PreferNoSchedule)
    - 이미 실행중인 파드를 노드로부터 축출할 수 있는 테인트(effect=NoExecute)
- 테인트와 톨러레이션은 독점적인 파드 세트를 전용 노드에 배치하는 등의 복잡한 사용 예를 허용하거나, 문제가 있는 노드에 테인트를 지정해 이 노드에 실행중인 파드를 강제로 축출할 수 있다

### 추가 고려사항
- 스케줄러에 너무 많은 제약을 가하면 파드가 더 이상 스케줄링되지 못하고 자원이 너무 많이 남겨지는 상황이 발생할 수 있음
  - 다른 컨테이너를 배치할 cpu가 없어 사용 불가한 4GB 메모리가 노드 A에 남겨진 상황
  - 자원 요구사항을 줄여서 컨테이너를 생성하거나 쿠버네티스 디스케줄러를 사용해 노드 조각 모음을 수행하고 활용도를 향상할 수 있음
- 파드가 노드에 할당되면 스케줄러 작업은 완료된 것으로 노드 추가 없이 파드가 삭제되어 다시 생성되지 않는 한 파드의 배치는 변경되지 않는다
  - 시간이 지남에 따라 자원 조각화와 클러스터 자원 활용률이 떨어질 수 있는 문제를 고려해야함
- 스케줄러의 결정은 파드가 스케줄링되는 그 시점의 클러스터에 기초한다
  - 클러스터가 유동적이며 노드의 자원 프로파일이 변하거나 새로운 노드가 추가되더라도 / 노드 용량 변경되거나 노드 레이블이 변경되더라도 스케줄러는 이전 파드 배치를 수정하지 않는다
- 쿠버네티스 디스케줄러
  - 위 문제들은 모두 디스케줄러에 의해 해결될 수 있는 시나리오
  - 클러스터 어드민이 파드를 다시 스케줄링해서 클러스터를 정리하고 조각모음을 수행하기에 적절한 시기라고 결정할 때마다 항상 작업으로서 실행되는 옵션 기능
  - 활성화와 조정이 가능한 또는 비활성화할 수 있는 사전 정의된 정책으로 제공된다
    - RemoveDupliate
    - LowNodeUtilization
    - RemovePodsViolatingInterPodAntiAffinity
    - RemovePodsViolatingNodeAffinity
    - 단 정책에 관계 없이 일부 파드는 축출하지 않는다
      - critical-pod 애노테이션으로 표시된 중요한 파드
      - 레플리카세트, 디플로이먼트, 잡에 의해 관리되지 않는 파드
      - 데몬세트에 의해 관리되지 않는 파드
      - 로컬 스토리지를 갖는 파드
      - 파드를 축출하면 PodDisruptionBudget규칙을 위반하게 되는 PodDisruptionBudget을 사용한 파드
      - 디스케줄파드 자신

## 정리
- 배치는 개입을 최소한으로 줄여야 하는 영역이다
- 아래 방법들로 파드 스케줄링을 제어할 수 있다
  - nodeName
  - nodeSelector
  - 기본 스케줄링 변경
  - 파드 어피니티와 안티어피니티
  - 노드 어피니티
  - 테인트와 톨러레이션
  - 사용자정의 스케줄러
- 컨테이너 자원 프로파일의 크기를 정하고 선언할 것, 파드와 노드에 적절하게 레이블을 지정할 것, 스케줄러에는 개입을 최소한으로 줄일 것
