# CHAPTER 4. 아키텍처 특성 정의
#### 소프트웨어 솔루션: 도메인 요구사항 + `아키텍처 특성`
아키텍트는 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 아키텍처 특성을 정의/발견/분석하는 일을 수행

</br>

### 아키텍처 특성이 충족하는 기준
#### 1. 비도메인 설계 고려 사항을 명시한다.
- 요구사항을 구현하는 방법, 운영/설계 기준 명시해야함
- 성능, 기술부채 방지 등은 당연히 중요한 특성이지만 요구사항 정의서에는 적혀있지 않은 경우가 많음
#### 2. 설계의 구조적 측면에 영향을 미친다.
- 아키텍트가 아키텍처 특성을 기술하는 주된 이유 : 설계 시 어떠한 특별한 구조적 요소를 고려해야하는지 생각하기 위함
- ex. 보안은 모든 프로젝트에서 주요 관심사이지만 특별한 케이스에서 아키텍처 특성 수준으로 격상하여 고려해야함
   - 서트파티 결제 프로세서가 아닌, 애플리케이션 내부에서 결제 처리를 해야하는 경우
#### 3. 어플리케이션 성공에 (절대적으로) 중요하다.
- 아키텍처 특성을 무수히 많이 지원하는 것은 무리 -> 특성을 한가지만 늘려도 그만큼 설계 복잡도가 가중되기 때문
- 가급적 특성을 적게 선정하는 일도 아키텍트의 중요한 책무
- 특성에는 명시적 특성과 암묵적 특성이 있음
  - 명시적: 요구사항 정의서 혹은 다른 지침서에 기재되는 특성
  - 암묵적: 가용성, 신뢰성, 보안 등. 모든 어플리케이션의 근간이지만 설계 문서에서는 잘 등장하지 않음

</br>

## 4.1 아키텍처 특성 목록
### 4.1.1 운영 아키텍처 특성
운영 및 데브옵스와 많은 부분에서 중첩됨
|용어|정의|
|---|---|
|가용성|시스템이 얼마나 오랫동안 사용 가능해야 하는지|
|연속성|재해 복구 능력|
|성능|스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간 등|
|복구성|비지니스 연속성 요구사항 (ex. 장애 발생 시 얼마나 신속하게 시스템을 재가동해야하는지)|
|신뢰성/안전|시스템에 fail-safe가 필요한지 (시스템 실패 시 거액의 손실이 발생하는지)|
|견고성|프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력|
|확장성|유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력|


### 4.1.2 구조 아키텍처 특성
- 아키텍트는 코드 구조에도 심혈을 기울여야 함
- 우수한 모듈성, 컴포넌트 간 커플링 제어, 가독성 높은 코드, 그 밖의 내부 품질 평가 등 코드 품질 문제 전담

|용어|정의|
|---|---|
|설정성|최종 유저가 소프트웨어 설정을 쉽게 바꿀 수 있는가|
|신장성|새로운 기능을 삽입하는 일의 중요성|
|설치성|필요한 모든 플랫폼에 시스템을 얼마나 손쉽게 설치할 수 있는지|
|활용성/재사용|공통 컴포넌트를 여러 제품에서 활용할 수 있는지|
|지역성|데이터를 입력/조회하는 화면에서 다국어가 지원되는지|
|유지보수성|시스템을 얼마나 쉽게 변경/개선할 수 있는지|
|이식성|하나 이상의 플랫폼에서 시스템을 실행할 수 있는지|
|지원성|애플리케이션이 어느 정도의 기술 지원을 필요로 하는지|
|업그레이드성|이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드 할 수 있는지|


### 4.1.3 아키텍처 공통 특성
따로 범주를 분류하기 어려운 특성
|용어|정의|
|---|---|
|접근성|장애인 등의 모든 유저가 접근하는 데 불편함이 없는지|
|보관성|데이터를 따로 아카이빙해야 하는지, 일정 시간 경과 후 삭제해야 하는지 등|
|인증|유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항|
|인가|유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항|
|합법성|시스템 운영상 법적 제약조건이 있는지|
|프라이버시|회사 내부 트랜잭션을 외부에 드러내지 않는 기능|
|보안|데이터 암호화한 후 데이터 베이스에 보관해야 하는지|
|사용성/성취성|유저가 애플리케이션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육 수준|

</br>

### 소프트웨어 아키텍처는 모호한 것 투성이
- 아키텍처 특성을 정의하는 용어들은 대부분 의미가 미묘하거나, 객관적으로 정의하기 어렵고 다소 부정확한 부분이 있음
   ex. 상호운용성과 호환성
    -  상호운용성: 다른 시스템과의 통합 용이성(API)
    -  호환성: 산업 표준/도메인 표준과 더 연관성 높음
- 정의가 중복되는 것들도 있음
   ex. 가용성과 신뢰성
- 대부분의 중요한 내용은 명확히 정의되어 있지 않기 때문에 동료들끼리 용어 때문에 오해하는 일이 없도록 서로 보편적인 언어를 정해서 사용하는게 좋음

</br>

## 4.2 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처
위에서 정의했던 모든 아키텍처 특성들을 애플리케이션에서 지원하기는 어려움
- 지원되는 특성마다 설계 노력이 필요하고 구조적으로 지원돼야 하므로
- 각 아키텍처 특성이 다른 특성에 영향을 미치는 경우가 많음
  ex. 보안 강화하려면 성능에 부정적인 영향을 미치기 쉬움(암호화 수행 과정에서 성능이 떨어짐)

#### 💡 TIP. 최고의 아키텍처를 고집하지 말고 가장 나쁘지 않은 아키텍처를 선택하는 것
- 아키텍처를 너무 욕심내다보면 실현 가능성이 낮아짐
- 꾸준히 조금씩 반복해서 설계해보자
