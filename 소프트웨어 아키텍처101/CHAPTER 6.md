# CHAPTER 6. 아키텍처 특성의 측정 및 거버넌스
## 6.1 아키텍처 특성 측정
#### 아키텍처 특성을 정의할 때 발생하는 문제?
- 물리학이 아니다 (특성의 의미가 대부분 모호하여 상황에 따라 의미가 정해지는 경우 많음)
- 정의가 너무 다양하다 (정의를 통일하지 않으면 원활한 소통이 어려움)
- 너무 복합적이다 (하나의 특성은 더 작은 여러 특성들로 구성됨. ex. 민첩성 = 모듈성+배포성+시험성)

</br>

### 6.1.1 운영적 측정
#### 1. 팀에 따라 측정에 따른 해석이 갈릴 수 있음
ex. 평균 응답 시간 측정의 경우, 1%의 요청이 다른 요청들보다 처리 시간이 10배가 걸린다면 최대 응답 시간도 함께 측정해야 특이점을 잡아낼 수 있음

#### 2. 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 정의에 기반하는 것이 좋음
ex. 확장성을 모니터링하는 비디오 스트리밍 서비스의 성능을 측정하는 경우, 아무 수치나 목표로 잡으면 X
1. 시간에 따라 어떤 추이를 보이는지 측정
2. 통계 모델 수립
3. 실시간 수집된 메트릭이 예측 모델에서 벗어난 경우 알림 메시지 발송

#### 3. 도구의 발전에 따라 팀이 측정할 수 있는 아키텍처 특성은 진화하고 있음
ex. 최초 콘텐츠 렌더링, 최초 CPU 유휴 같은 메트릭을 통해 모바일 기기로 접속한 유저의 성능 측정 가능

</br>

### 6.1.2 구조적 측정
**성능** 처럼 목표치가 확실하지 않은 메트릭은 공통 도구를 이용해서 코드 구조에 대한 부분을 확인할 수 있음
#### 순환 복잡도 (Cyclomatic Complexity)
- 함수/메서드, 클래스, 또는 애플리케이션 레벨에서 코드 복잡도를 객관적으로 나타내는 지표
- 코드에 그래프 이론을 적용하여 계산
- `CC = E - N + 2P`
  - E: 간선(가능한 결정)
  - N: 노드(코드 라인)
  - P: 연결된 컴포넌트 수(다른 메서드 호출 수)
- 아래 예시 ) CC = 5 - 4 + 2 = 3
```c
public void decision(int c1, int c2) {
  if (c1 < 100)
    return 0;
  else if (c1 + c2 > 500)
    return -1;
  else
    return 1;
}
```
<img width="500" alt="스크린샷 2024-11-26 오후 6 09 21" src="https://open.oss.navercorp.com/storage/user/2886/files/7bca53f2-0f84-42a4-a764-6df20c121bff">

</br>

#### 순환 복잡도는 어느 정도가 적당한가?
- 도메인 자체의 복잡도를 고려하지 않을 경우, 일반적으로 10 이하의 CC는 괜찮음
- 5 이하로 나오는 경우 응집도가 괜찮은 짜임새 있는 코드
- 50 이상의 CC는 코드 커버리지를 아무리 높여도 문제가 있음
- 자바 진영에서는 `Crap4J`라는 측정 도구로 CC와 코드 커버리지를 함께 측정 가능. (+ 파이썬은 [radon](https://pypi.org/project/radon/)이라는 패키지 있음)
- TDD를 실천하여 간단한 테스트를 작성하고, 테스트를 통과하는 가장 적은 양의 코드를 작성하면 짜임새 있고 응집된 메서드 개발 가능

</br>

### 6.1.3 프로세스 측정
- 개발의 영역과 겹치는 아키텍처 특성도 있음(ex. 민첩성 = 시험성 + 배포성)
- **시험성**은 코드 커버리지 도구로 측정할 수 있음
   (그러나, 코드 커버리지가 100%이더라도 assertion이 형편없으면 신뢰감을 부여하기는 어려움)
- **배포성**은 배포 성공률, 소요 시간, 배포 시 발생한 이슈/버그 등 다양한 메트릭으로 측정 가능
- 위처럼 민첩성은 개발 프로세스와도 연관이 있지만, 아키텍트는 아키텍처 수준에서 모듈성, 격리성을 높이는데 주력할 수 있음

</br>

## 6.1 거버넌스와 피트니스 함수
- 아키텍트가 아키텍처 특성을 확정하고 우선순위를 결정하더라도 개발자들이 이 우선순위를 지킬거라고 확신할 수 없음
- 때문에 아키텍트는 거버넌스 메커니즘을 강구해야 함


### 6.2.1 아키텍처 특성 관리
- 아키텍처 거버넌스는 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄
- 최근에는 좋은 솔루션들이 많이 등장하여 아키텍처 거버넌스의 여러 부분을 자동화 → 피트니스 함수라는 기법 소개


### 6.2.2 피트니스 함수
결과가 목표에 얼마나 근접했는지 나타내는 목표 함수

#### 아키텍처 피트니스 함수
- 어떤 아키텍처 특성의 객관적인 무결성을 평가하는 모든 메커니즘
- 사용하는 방법에 따라 메트릭, 모니터, 단위 테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있음

#### 순환 의존성
- **모듈성**은 암묵적인 아키텍처의 특성 
- 아래처럼 각 컴포넌트가 다른 컴포넌트에 있는 코드를 참조하는 경우, 개발자는 어느 한 컴포넌트를 재사용하기 위해 그에 딸린 다른 컴포넌트들도 가져와야 하므로 모듈성이 매우 떨어짐
  <img width="469" alt="스크린샷 2024-11-26 오후 6 41 11" src="https://open.oss.navercorp.com/storage/user/2886/files/23efccd4-a7f6-44f9-aa36-9f6b9a4911bf">
- 피트니스 함수로 순환 참조 여부를 발견함으로써 해결할 수 있음
- 자바의 경우 `JDepend`라는 메트릭 도구로 패키지 간 의존성 체크 (파이썬에서 `gc`)
- fastapi에서는 애플리케이션 시작 시 import error

#### '메인 시퀀스로부터의 거리' 피트니스 함수
- 3.2 절에 소개했던 메트릭
- `JDepend` 활용 테스트 코드
```Java
@Test
void AllPackages() {
    double ideal = 0.0;
    double tolerance = 0.5; // 프로젝트마다 값이 다름
    Collection packages = jdepend.analyze();
    Iterator iter = packages.iterator();
    while (iter.hasNext()) {
        JavaPackage p = (JavaPackage)iter.next();
        assertEquals("Distance exceeded: " + p.getName(), ideal, p.distance(), tolerance);
    }
}
```

#### 레이어드 아키텍처에서의 순환 참조

<img width="400" alt="스크린샷 2024-11-26 오후 6 50 37" src="https://open.oss.navercorp.com/storage/user/2886/files/6bf2e20b-be91-4f95-bf9b-0272d3ec2e59">

- 각 레이어 간의 올바른 의존 관계를 정의하고 이를 실천할 수 있도록 검증하는 테스트 코드 생성 가능

#### 넷플릭스의 [Chaos Monkey](https://github.com/Netflix/chaosmonkey)
- 비디오 스트리밍 서비스로 전환하던 초기에 자사 시스템의 탄력성과 회복성을 제고시키기 위해 고안한 소프트웨어 도구
- 서비스를 공급하는 인스턴스를 무작위로 셧다운
- 추후 예상치 못한 장애가 발생했을 때 시스템이 스스로 복구할 수 있게 하는 등의 작업을 미리 할 수 있음
- 이후 '카오스 엔지니어링'이라는 방법론으로 발전


#### 💡 아키텍트는 멍키 혹은 피트니스 함수 같은 도구들을 활용하여 중요한 거버넌스 체크를 아키텍처 하부에 구체화 할 수 있음
